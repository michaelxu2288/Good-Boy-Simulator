<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Naughty Beast Simulator 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; text-shadow: 1px 1px 2px black; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; }
        p { margin: 5px 0; font-size: 16px; }
        #score-display { font-size: 30px; color: #ff69b4; font-weight: bold; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; font-weight: bold; text-shadow: 2px 2px 4px black; display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>üêï Naughty Beast Simulator</h1>
        <p><b>WASD / Arrows</b> to Move</p>
        <p><b>SPACE</b> to Mount (Must be near Owner)</p>
        <p>Pleasure Points: <span id="score-display">0</span></p>
    </div>
    <div id="message">WOOF! (Mount Me!)</div>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x4B0082); // Dim indigo for intimate atmosphere
        scene.fog = new THREE.Fog(0x4B0082, 5, 50); // Increased far for open space
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 15);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xff69b4, 0.3); // Pinkish ambient for NSFW vibe
        scene.add(ambientLight);
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0xff69b4, 2.0, 20, Math.PI / 4, 0.5);
        spotLight.position.set(0, 10, 0);
        spotLight.castShadow = true;
        scene.add(spotLight);
        // --- ENVIRONMENT (OPEN SPACE) ---
        // Floor (Carpet) - Larger for open space
        const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10); // Larger repeat
        const floorGeo = new THREE.PlaneGeometry(100, 100); // Larger floor
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.8, metalness: 0 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        // No walls for open space
        const walls = []; // Empty, no walls
        // Bed (Central Furniture)
        const bedFrame = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 10), new THREE.MeshStandardMaterial({ color: 0x800000, roughness: 0.2 }));
        bedFrame.position.set(0, 0.5, 0);
        bedFrame.castShadow = true;
        scene.add(bedFrame);
        const mattress = new THREE.Mesh(new THREE.BoxGeometry(7.5, 1, 9.5), new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }));
        mattress.position.set(0, 1.5, 0);
        mattress.castShadow = true;
        scene.add(mattress);
        walls.push(bedFrame, mattress); // Collision (though not implemented)
        // Removed nightstand for open space
        // --- PLAYER (DOG) - Fixed Torso Orientation ---
        const dogGroup = new THREE.Group();
        // Body (Torso) - Corrected rotation to lie along Z-axis
        const bodyGeo = new THREE.CylinderGeometry(0.4, 0.4, 4, 32);
        const furTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        furTexture.wrapS = furTexture.wrapT = THREE.RepeatWrapping;
        furTexture.repeat.set(2, 1);
        const dogMat = new THREE.MeshStandardMaterial({ map: furTexture, color: 0x8B4513, roughness: 0.7 });
        const body = new THREE.Mesh(bodyGeo, dogMat);
        body.position.y = 1.0;
        body.rotation.x = -Math.PI / 2; // Corrected to along Z-axis
        body.castShadow = true;
        dogGroup.add(body);
        // Legs - Adjusted for better stance
        function createDogLeg(x, y, z) {
            const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 1.2, 16);
            const leg = new THREE.Mesh(legGeo, dogMat);
            leg.position.set(x, y, z);
            leg.castShadow = true;
            dogGroup.add(leg);
        }
        createDogLeg(0.25, 0.6, 1.5);
        createDogLeg(-0.25, 0.6, 1.5);
        createDogLeg(0.25, 0.6, -1.5);
        createDogLeg(-0.25, 0.6, -1.5);
        // Head
        const headGeo = new THREE.SphereGeometry(0.45, 32, 32);
        const head = new THREE.Mesh(headGeo, dogMat);
        head.position.set(0, 1.0, 2.1);
        head.castShadow = true;
        dogGroup.add(head);
        // Snout
        const snoutGeo = new THREE.ConeGeometry(0.25, 1.0, 32);
        const snout = new THREE.Mesh(snoutGeo, dogMat);
        snout.position.set(0, 1.0, 2.6);
        snout.rotation.x = Math.PI / 2; // Adjusted for Z-orientation
        snout.castShadow = true;
        dogGroup.add(snout);
        // Ears
        function createEar(x, rot) {
            const earGeo = new THREE.ConeGeometry(0.25, 0.7, 16);
            const ear = new THREE.Mesh(earGeo, dogMat);
            ear.position.set(x, 1.4, 2.0);
            ear.rotation.z = rot;
            dogGroup.add(ear);
        }
        createEar(0.3, -0.7);
        createEar(-0.3, 0.7);
        // Tail
        const tailGeo = new THREE.CylinderGeometry(0.12, 0.05, 1.5, 16);
        const tail = new THREE.Mesh(tailGeo, dogMat);
        tail.position.set(0, 1.0, -2.0);
        tail.rotation.x = 0.3;
        dogGroup.add(tail);
        // Genitals (NSFW)
        const phallusGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 16);
        const phallusMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.3 });
        const phallus = new THREE.Mesh(phallusGeo, phallusMat);
        phallus.position.set(0, 0.6, -1.5);
        phallus.rotation.x = Math.PI / 2;
        phallus.visible = false;
        dogGroup.add(phallus);
        scene.add(dogGroup);
        dogGroup.position.set(0, 0, 10);
        // --- OWNER (HUMAN FEMALE) - More Normal Proportions ---
        const ownerGroup = new THREE.Group();
        // Torso - Adjusted for more natural shape
        const torsoGeo = new THREE.CylinderGeometry(0.4, 0.5, 2.2, 32); // Slightly taller
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdab9, roughness: 0.5, metalness: 0 });
        const torso = new THREE.Mesh(torsoGeo, skinMat);
        torso.position.y = 2.1;
        torso.castShadow = true;
        ownerGroup.add(torso);
        // Head - Proportional
        const ownerHeadGeo = new THREE.SphereGeometry(0.35, 32, 32);
        const ownerHead = new THREE.Mesh(ownerHeadGeo, skinMat);
        ownerHead.position.y = 3.4; // Adjusted up
        ownerHead.castShadow = true;
        ownerGroup.add(ownerHead);
        // Hair
        const hairGeo = new THREE.SphereGeometry(0.4, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
        const hairMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.8 });
        const hair = new THREE.Mesh(hairGeo, hairMat);
        hair.position.y = 3.5;
        ownerGroup.add(hair);
        // Ponytail
        const ponytailGeo = new THREE.CylinderGeometry(0.1, 0.05, 2, 32);
        const ponytail = new THREE.Mesh(ponytailGeo, hairMat);
        ponytail.position.set(0, 3.0, -0.3);
        ponytail.rotation.x = Math.PI / 6;
        ownerGroup.add(ponytail);
        // Breasts - Adjusted position
        function createBreast(x) {
            const breastGeo = new THREE.SphereGeometry(0.4, 32, 32); // Slightly smaller for normal
            const breast = new THREE.Mesh(breastGeo, skinMat);
            breast.position.set(x, 2.6, 0.2);
            breast.castShadow = true;
            ownerGroup.add(breast);
            // Nipple
            const nippleGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const nippleMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.3 });
            const nipple = new THREE.Mesh(nippleGeo, nippleMat);
            nipple.position.set(x, 2.6, 0.6);
            ownerGroup.add(nipple);
        }
        createBreast(0.3);
        createBreast(-0.3);
        // Hips/Butt - Adjusted scale
        const hipsGeo = new THREE.SphereGeometry(0.65, 32, 32);
        const hips = new THREE.Mesh(hipsGeo, skinMat);
        hips.position.y = 1.0;
        hips.scale.set(1.2, 0.65, 1.1); // Slightly less exaggerated
        hips.castShadow = true;
        ownerGroup.add(hips);
        // Legs - Adjusted for normal shape
        function createHumanLeg(x, rot) {
            // Upper leg (thigh)
            const thighGeo = new THREE.CylinderGeometry(0.22, 0.18, 1.6, 32); // Slightly slimmer
            const thigh = new THREE.Mesh(thighGeo, skinMat);
            thigh.position.set(x, 1.8, 0);
            thigh.rotation.z = rot;
            thigh.castShadow = true;
            ownerGroup.add(thigh);
            // Lower leg
            const lowerLegGeo = new THREE.CylinderGeometry(0.16, 0.13, 1.6, 32);
            const lowerLeg = new THREE.Mesh(lowerLegGeo, skinMat);
            lowerLeg.position.set(x, 0.8, 0);
            lowerLeg.rotation.z = rot;
            lowerLeg.castShadow = true;
            ownerGroup.add(lowerLeg);
            // Foot
            const footGeo = new THREE.BoxGeometry(0.25, 0.2, 0.5);
            const foot = new THREE.Mesh(footGeo, skinMat);
            foot.position.set(x, 0.1, 0.15);
            foot.castShadow = true;
            ownerGroup.add(foot);
        }
        createHumanLeg(0.35, -0.05); // Less wide
        createHumanLeg(-0.35, 0.05);
        // Arms - Adjusted
        function createHumanArm(x, rot) {
            // Upper arm
            const upperArmGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.3, 32);
            const upperArm = new THREE.Mesh(upperArmGeo, skinMat);
            upperArm.position.set(x, 3.0, 0);
            upperArm.rotation.z = rot;
            upperArm.castShadow = true;
            ownerGroup.add(upperArm);
            // Lower arm
            const lowerArmGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.3, 32);
            const lowerArm = new THREE.Mesh(lowerArmGeo, skinMat);
            lowerArm.position.set(x * 1.1, 2.2, 0);
            lowerArm.rotation.z = rot;
            lowerArm.castShadow = true;
            ownerGroup.add(lowerArm);
            // Hand
            const handGeo = new THREE.SphereGeometry(0.14, 16, 16);
            const hand = new THREE.Mesh(handGeo, skinMat);
            hand.position.set(x * 1.15, 1.9, 0);
            hand.castShadow = true;
            ownerGroup.add(hand);
        }
        createHumanArm(0.55, Math.PI / 4);
        createHumanArm(-0.55, -Math.PI / 4);
        // Genitals (NSFW)
        const vaginaGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16);
        const vaginaMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.2 });
        const vagina = new THREE.Mesh(vaginaGeo, vaginaMat);
        vagina.position.set(0, 1.0, 0.35);
        vagina.rotation.x = Math.PI / 2;
        ownerGroup.add(vagina);
        // Labia
        const labiaGeo = new THREE.TorusGeometry(0.15, 0.05, 16, 32);
        const labia = new THREE.Mesh(labiaGeo, vaginaMat);
        labia.position.set(0, 1.0, 0.35);
        labia.rotation.x = Math.PI / 2;
        ownerGroup.add(labia);
        scene.add(ownerGroup);
        ownerGroup.position.set(5, 0, -5);
        // --- GAME LOGIC ---
        let score = 0;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let canMount = true;
        let mounting = false;
        let mountTimer = 0;
        // Input Handling
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'Space') keys.space = true;
            if (key === 'arrowup') keys.w = true;
            if (key === 'arrowdown') keys.s = true;
            if (key === 'arrowleft') keys.a = true;
            if (key === 'arrowright') keys.d = true;
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
            if (key === 'arrowup') keys.w = false;
            if (key === 'arrowdown') keys.s = false;
            if (key === 'arrowleft') keys.a = false;
            if (key === 'arrowright') keys.d = false;
        });
        function showMessage(text = 'WOOF! (Mount Me!)') {
            const msg = document.getElementById('message');
            msg.innerText = text;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 1000);
        }
        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            // 1. Dog Movement
            if (!mounting) {
                const speed = 8 * delta;
                const turnSpeed = 4 * delta;
                if (keys.a) dogGroup.rotation.y += turnSpeed;
                if (keys.d) dogGroup.rotation.y -= turnSpeed;
                const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), dogGroup.rotation.y); // Adjusted for positive Z facing
                const nextPos = dogGroup.position.clone();
                if (keys.w) nextPos.add(forward.multiplyScalar(speed));
                if (keys.s) nextPos.add(forward.multiplyScalar(-speed));
                // Boundary Check - Larger for open space
                if (nextPos.x > -49 && nextPos.x < 49 && nextPos.z > -49 && nextPos.z < 49) {
                    dogGroup.position.copy(nextPos);
                }
            }
            // Tail Wag
            tail.rotation.y = Math.sin(Date.now() * 0.01) * 0.5;
            // 2. Camera Follow - Better angle during mount (side view)
            let relativeCameraOffset = new THREE.Vector3(0, 3, 10);
            if (mounting) {
                relativeCameraOffset.set(5, 3, 2); // Side and slightly back for better view
            }
            const cameraOffset = relativeCameraOffset.applyMatrix4(dogGroup.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(dogGroup.position);
            // 3. Owner AI
            const distToOwner = dogGroup.position.distanceTo(ownerGroup.position);
            if (ownerState === 'IDLE') {
                ownerTimer += delta;
                if (ownerTimer > 3) {
                    ownerTarget.set( (Math.random() * 80) - 40, 0, (Math.random() * 80) - 40 ); // Larger range for open space
                    ownerState = 'MOVING';
                    ownerTimer = 0;
                }
            } else if (ownerState === 'MOVING') {
                const direction = new THREE.Vector3().subVectors(ownerTarget, ownerGroup.position).normalize();
                ownerGroup.position.add(direction.multiplyScalar(3 * delta));
                ownerGroup.lookAt(ownerTarget);
                if (ownerGroup.position.distanceTo(ownerTarget) < 1) {
                    ownerState = 'IDLE';
                }
            } else if (ownerState === 'BENT_OVER') {
                ownerGroup.position.y = Math.sin(Date.now() * 0.01) * 0.05;
            }
            // 4. Mounting
            if (keys.space && canMount && !mounting) {
                if (distToOwner < 2) {
                    showMessage('Ahh~ Yes, Good Boy!');
                    mounting = true;
                    canMount = false;
                    phallus.visible = true;
                    ownerState = 'BENT_OVER';
                    ownerGroup.rotation.x = Math.PI / 2;
                    dogGroup.position.lerp(ownerGroup.position.clone().add(new THREE.Vector3(0, 0, -1)), 0.5);
                    dogGroup.lookAt(ownerGroup.position);
                    mountTimer = 5;
                }
            }
            if (mounting) {
                mountTimer -= delta;
                phallus.position.z = Math.sin(Date.now() * 0.02) * 0.2 - 0.5;
                vagina.scale.y = 1 + Math.sin(Date.now() * 0.02) * 0.1;
                if (mountTimer <= 0) {
                    mounting = false;
                    phallus.visible = false;
                    ownerState = 'IDLE';
                    ownerGroup.rotation.x = 0;
                    score += 10;
                    document.getElementById('score-display').innerText = score;
                    const s = 1 + (score * 0.02);
                    dogGroup.scale.set(s, s, s);
                    setTimeout(() => { canMount = true; }, 5000);
                }
            }
            renderer.render(scene, camera);
        }
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // Owner Data
        let ownerTarget = new THREE.Vector3(5, 0, -5);
        let ownerState = 'IDLE';
        let ownerTimer = 0;
        animate();
    </script>
</body>
</html>